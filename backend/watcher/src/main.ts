import fs from 'fs'
import {
  DynamoDBClient,
  ScanCommand,
  GetItemCommand,
  TransactWriteItem,
  TransactWriteItemsCommand,
} from '@aws-sdk/client-dynamodb'
import {marshall, unmarshall} from '@aws-sdk/util-dynamodb'

import {ExecutionResult} from 'graphql'
import {createClient, RequestParams} from 'graphql-http'

const ZERO_ADDRESS = '0x0000000000000000000000000000000000000000000000000000000000000000'

// in seconds
const DB_WRITE_SLEEP = 3
const API_FETCH_SLEEP = 2

const TESTNET_ENDPOINT = 'https://sui-testnet.mystenlabs.com/graphql'
const TABLE_DEPLOYED = 's3m-contracts-dev'
// key: (address_package, timestamp)
// rest: event, sender, receiver, amount, timestamp (insert row)
const EVENTS_TABLE = 's3m-contracts-events-dev'
// key: (ticker, address)
// rest: balance, ltimestamp of last change (upsert row)
const BALANCES_TABLE = 's3m-balances-dev'
// key: address_package,
// rest: timestamp of last event
const LASTFETCH_TABLE = 's3m-contracts-lastfetch-dev'

// timestamp = timestamp in event
// ltimestamp = timestamp generated by server (UTC)
// address_package = address::package
// ticker = "$" + package.upper()

const gclient = createClient({
  url: TESTNET_ENDPOINT,
  fetchFn: fetch,
})
const dbclient = new DynamoDBClient()

// docs: https://docs.sui.io/references/sui-api/sui-graphql/reference/queries/events
const queryFirst = `
query($module: String!, $evType: String!) {
  events(
    first: 10
    filter: { emittingModule: $module, eventType: $evType }
  ) {
    pageInfo { hasNextPage, endCursor }
    nodes {
      type { repr }
      timestamp
      sendingModule {
        name
        package { address }
      }
      sender { address }
      json
    }
  }
}
`

const queryForwardSubsequent = `
query($module: String!, $evType: String!, $after: String!) {
  events(
    first: 10
    after: $after
    filter: { emittingModule: $module, eventType: $evType }
  ) {
    pageInfo { hasNextPage, endCursor }
    nodes {
      type { repr }
      timestamp
      sendingModule {
        name
        package { address }
      }
      sender { address }
      json
    }
  }
}
`

const queryLast = `
query($module: String!, $evType: String!) {
  events(
    last: 2
    filter: { emittingModule: $module, eventType: $evType }
  ) {
    pageInfo { hasNextPage, endCursor, startCursor }
    nodes {
      type { repr }
      timestamp
      sendingModule {
        name
        package { address }
      }
      sender { address }
      json
    }
  }
}
`

const queryLastSubsequent = `
query($module: String!, $evType: String!, $before: String!) {
  events(
    last: 2
    before: $before
    filter: { emittingModule: $module, eventType: $evType }
  ) {
    pageInfo { hasNextPage, endCursor, startCursor }
    nodes {
      type { repr }
      timestamp
      sendingModule {
        name
        package { address }
      }
      sender { address }
      json
    }
  }
}
`
async function sleep(secs) {
  console.log(`sleeping for ${secs} seconds`)
  return new Promise(resolve => setTimeout(resolve, secs * 1000))
}

function packageSummary(objectChanges) {
  for (const obj of objectChanges) {
    if (obj.type === 'published') {
      return obj.packageId
    }
  }
  return '' // shouldn't happen
}

// FIXME: instead of scanning the whole table, we use the lastfetch table
// change the backend to store the last fetch details
async function getPackageModules(): Promise<string[]> {
  const packages: string[] = []

  const command = new ScanCommand({
    TableName: TABLE_DEPLOYED,
    FilterExpression: 'deploy_status = :status',
    ExpressionAttributeValues: {
      ':status': {S: 'published'},
    },
  })

  const result = await dbclient.send(command)
  const items = result.Items?.map(item => unmarshall(item)) ?? []

  items.forEach(item => {
    const deploy_data = item.deploy_data
    for (const obj of deploy_data?.objectChanges ?? []) {
      if (obj.type === 'published') {
        packages.push(`${obj.packageId}::${item.package_name}`)
        break
      }
    }
  })

  return packages
}

async function lastFetchEventTime(pkg: string): Promise<string> {
  const command = new GetItemCommand({
    TableName: LASTFETCH_TABLE,
    Key: {
      address_package: {S: pkg},
    },
  })

  const response = await dbclient.send(command)
  if (response.Item === undefined) return ''

  const item = unmarshall(response.Item)

  return item.timestamp ?? ''
}

async function getTokenEvents(module: string, token: string): Promise<[string, object[], boolean]> {
  console.log(`fetching ${module}`)

  let cancel = () => {}
  const result: ExecutionResult<Record<string, unknown>, unknown> = await new Promise((resolve, reject) => {
    let innerResult
    if (token === '') {
      cancel = gclient.subscribe(
        {
          query: queryFirst,
          variables: {module: module, evType: module},
        },
        {
          next: data => (innerResult = data),
          error: reject,
          complete: () => resolve(innerResult),
        },
      )
    } else {
      cancel = gclient.subscribe(
        {
          query: queryForwardSubsequent,
          variables: {module: module, evType: module, after: token},
        },
        {
          next: data => (innerResult = data),
          error: reject,
          complete: () => resolve(innerResult),
        },
      )
    }
  })

  if ('errors' in result) {
    console.log(JSON.stringify(result.errors, null, 2))
    return ['', [], true]
  }

  if ('data' in result && 'events' in result.data!) {
    const new_token = result.data.events!['pageInfo'].endCursor
    const events = result.data.events!['nodes'] ?? []
    const etime = events[events.length - 1].timestamp
    const done = !result.data.events!['pageInfo'].hasNextPage ?? true
    return [new_token, events, done]
  } else {
    return ['', [], true]
  }
}

async function getTokenEventsBackwards(
  module: string,
  token: string,
  stopTime: string,
): Promise<[string, object[], boolean]> {
  // console.log(`fetching ${module} backwards`)

  let cancel = () => {}
  const result: ExecutionResult<Record<string, unknown>, unknown> = await new Promise((resolve, reject) => {
    let innerResult
    if (token === '') {
      cancel = gclient.subscribe(
        {
          query: queryLast,
          variables: {module: module, evType: module},
        },
        {
          next: data => (innerResult = data),
          error: reject,
          complete: () => resolve(innerResult),
        },
      )
    } else {
      cancel = gclient.subscribe(
        {
          query: queryLastSubsequent,
          variables: {module: module, evType: module, before: token},
        },
        {
          next: data => (innerResult = data),
          error: reject,
          complete: () => resolve(innerResult),
        },
      )
    }
  })

  if ('errors' in result) {
    console.log(JSON.stringify(result.errors, null, 2))
    return ['', [], true]
  }

  /*
   assume our page size is 5
   on the first run there are 4 events and we fetch 2024-01-01, 2024-01-02, 2024-01-03, 2024-01-04
   set stopTime to 2024-01-04
   two more events occur
   on the next run, when we go fetch 5 events backwards, we fetch
   2024-01-02, 2024-01-03, 2024-01-04, 2024-01-05, 2024-01-06
   reverse them: 2024-01-06, 2024-01-05, 2024-01-04, 2024-01-03, 2024-01-02
   the last event in our reversed list is 2024-01-02
   is stopTime >= lastEvent?  yes, so we're done
   later on, we reverse all the events and filter out events that are <= stopTime
   which leaves us with 2024-01-05, 2024-01-06
   */
  if ('data' in result && 'events' in result.data!) {
    const new_token = result.data.events!['pageInfo'].startCursor
    // when we fetch events, we get them in chronological order, oldest to newest
    // reverse it so it's newest to oldest
    const events = (result.data.events!['nodes'] ?? []).reverse()
    // events.forEach(event => {
    //  console.log(`---- ${event.timestamp}`)
    //})
    const etime = events[events.length - 1].timestamp
    const done = stopTime >= etime
    console.log(`---- new_token: ${new_token}, done: ${done}, etime: ${etime}, cmp : ${stopTime >= etime}`)
    // console.log(JSON.stringify(events, null, 2))
    console.log('----')
    return [new_token, events, done]
  } else {
    return ['', [], true]
  }
}

async function saveEvents(pkg: string, events: Record<string, any>[], new_token: string) {
  const ltimestamp = events[events.length - 1].timestamp
  console.log(`saving for ${pkg}, ts ${ltimestamp}, events: ${events.length}`)
  fs.writeFileSync(`/tmp/${pkg}`, JSON.stringify(events))

  // balance changes
  // sender = 0x0 should show up in mint only
  const balances: Record<string, number> = {}

  let items: TransactWriteItem[] = [
    // update timestamp and new_token in TABLE_LASTFETCH
    {
      Update: {
        TableName: LASTFETCH_TABLE,
        Key: {
          address_package: {S: pkg},
        },
        UpdateExpression: 'SET timestamp = :timestamp',
        ExpressionAttributeValues: {
          ':timestamp': {S: ltimestamp},
        },
      },
    },
  ]

  // put events in EVENTS_TABLE
  for (const event of events) {
    const item = {
      address_package: pkg,
      timestamp: event.timestamp,
      event: event.type.repr.split(/::/).pop(),
      sender: '',
      receiver: '',
      json: event.json ?? {},
    }

    switch (item.event) {
      case 'EventMint':
        item.sender = ZERO_ADDRESS
        item.receiver = event.json.address
        balances[item.receiver] = (balances[item.receiver] ?? 0) + parseInt(event.json.amount, 10)
        break
      case 'EventBurn':
        item.sender = event.json.address
        item.receiver = ZERO_ADDRESS
        balances[item.sender] = (balances[item.sender] ?? 0) - parseInt(event.json.amount, 10)
        break
      case 'EventTransfer':
        // old style mint: EventMint
        // new style mint: EventMint + EventTransfer; skip
        if (event.json.sender == ZERO_ADDRESS) {
          continue
        }
        item.sender = event.json.sender
        item.receiver = event.json.receiver
        balances[item.sender] = (balances[item.sender] ?? 0) - parseInt(event.json.amount, 10)
        balances[item.receiver] = (balances[item.receiver] ?? 0) + parseInt(event.json.amount, 10)
        break
      case 'EventPaused':
      case 'EventUnpaused':
        item.sender = event.sender.address
        break
      case 'EventTransfersFrozen':
      case 'EventTransfersUnfrozen':
        item.sender = event.sender.address
        break
      default:
        console.log(`unknown event: ${item.event}`)
        item.sender = event.sender.address
    }

    items.push({
      Put: {
        TableName: EVENTS_TABLE,
        Item: marshall(item, {removeUndefinedValues: true}),
      },
    })
  }

  // update balances in BALANCES_TABLE
  for (const [address, balance] of Object.entries(balances)) {
    items.push({
      Update: {
        TableName: BALANCES_TABLE,
        Key: {
          ticker: {S: `$${pkg.split('::')[1].toUpperCase()}`},
          address: {S: address},
        },
        UpdateExpression: 'ADD balance :balance SET ltimestamp = :ltimestamp',
        ExpressionAttributeValues: {
          ':balance': {N: `${balance}`},
          ':ltimestamp': {S: ltimestamp},
        },
      },
    })
  }

  const txWriteCommand = new TransactWriteItemsCommand({
    TransactItems: items,
  })

  await dbclient.send(txWriteCommand)
}

void (async () => {
  const packages = await getPackageModules()
  console.log(JSON.stringify(packages, null, 2))

  // for (const pkg of ['0xffa422771a3d41c8c2b97570d2ccf916e25aa4c42de21c1167256a377a57393d::play']) {
  for (const pkg of packages) {
    let ltime = await lastFetchEventTime(pkg)
    let packageEvents: object[] = []
    let packageDone = false
    const forward = ltime == ''

    let token = ''
    while (!packageDone) {
      let new_token = ''
      let events: object[]
      let done = false
      if (forward) {
        ;[new_token, events, done] = await getTokenEvents(pkg, token)
      } else {
        ;[new_token, events, done] = await getTokenEventsBackwards(pkg, token, ltime)
      }
      packageEvents.push(...events)
      packageDone = done
      token = new_token
      console.log(`fetched events for ${pkg}: ${events.length}, new token is ${token} done ${packageDone}`)

      if (packageDone) {
        if (packageEvents.length > 0) {
          if (!forward) {
            packageEvents = packageEvents.reverse()
            packageEvents = packageEvents.filter(event => event['timestamp'] > ltime)
          }
          const ltimestamp = packageEvents[packageEvents.length - 1]['timestamp'] ?? 'XXX'
          console.log(`saving for ${pkg}, ts ${ltimestamp}, events: ${packageEvents.length}`)
          fs.writeFileSync(`/tmp/${pkg}`, JSON.stringify(packageEvents))

          // await saveEvents(pkg, packageEvents, new_token)
          // await sleep(DB_WRITE_SLEEP)
        }
      } else {
        await sleep(API_FETCH_SLEEP)
      }
    }
  }
})()
