import fs from 'fs'
import {
  DynamoDBClient,
  ScanCommand,
  GetItemCommand,
  TransactWriteItem,
  TransactWriteItemsCommand,
} from '@aws-sdk/client-dynamodb'
import {marshall, unmarshall} from '@aws-sdk/util-dynamodb'

import {ExecutionResult} from 'graphql'
import {createClient, RequestParams} from 'graphql-http'

const ZERO_ADDRESS = '0x0000000000000000000000000000000000000000000000000000000000000000'

// in seconds
const DB_WRITE_SLEEP = 3
const API_FETCH_SLEEP = 2

const TESTNET_ENDPOINT = 'https://sui-testnet.mystenlabs.com/graphql'
const TABLE_DEPLOYED = 's3m-contracts-dev'
// key: (address_package, timestamp)
// rest: event, sender, receiver, amount (insert row)
const EVENTS_TABLE = 's3m-contracts-events-dev'
// key: (ticker, address)
// rest: balance, ltimestamp of last change (upsert row)
const BALANCES_TABLE = 's3m-balances-dev'
// key: address_package
// rest: endCursor, ltimestamp
const LASTFETCH_TABLE = 's3m-contracts-lastfetch-dev'

// timestamp = timestamp in event
// ltimestamp = timestamp generated by server (UTC)
// address_package = address::package
// ticker = "$" + package.upper()

const gclient = createClient({
  url: TESTNET_ENDPOINT,
  fetchFn: fetch,
})
const dbclient = new DynamoDBClient()

// docs: https://docs.sui.io/references/sui-api/sui-graphql/reference/queries/events
const queryFirst = `
query($module: String!, $evType: String!) {
  events(
    first: 10
    filter: { emittingModule: $module, eventType: $evType }
  ) {
    pageInfo { hasNextPage, endCursor }
    nodes {
      type { repr }
      timestamp
      sendingModule {
        name
        package { address }
      }
      sender { address }
      json
    }
  }
}
`

const querySubsequent = `
query($module: String!, $evType: String!, $after: String!) {
  events(
    first: 10
    after: $after
    filter: { emittingModule: $module, eventType: $evType }
  ) {
    pageInfo { hasNextPage, endCursor }
    nodes {
      type { repr }
      timestamp
      sendingModule {
        name
        package { address }
      }
      sender { address }
      json
    }
  }
}
`
async function sleep(secs) {
  console.log(`sleeping for ${secs} seconds`)
  return new Promise(resolve => setTimeout(resolve, secs * 1000))
}

function packageSummary(objectChanges) {
  for (const obj of objectChanges) {
    if (obj.type === 'published') {
      return obj.packageId
    }
  }
  return '' // shouldn't happen
}

// FIXME: instead of scanning the whole table, we use the lastfetch table
// change the backend to store the last fetch details
async function getPackageModules(): Promise<string[]> {
  const packages: string[] = []

  const command = new ScanCommand({
    TableName: TABLE_DEPLOYED,
    FilterExpression: 'deploy_status = :status',
    ExpressionAttributeValues: {
      ':status': {S: 'published'},
    },
  })

  const result = await dbclient.send(command)
  const items = result.Items?.map(item => unmarshall(item)) ?? []

  items.forEach(item => {
    const deploy_data = item.deploy_data
    for (const obj of deploy_data?.objectChanges ?? []) {
      if (obj.type === 'published') {
        packages.push(`${obj.packageId}::${item.package_name}`)
        break
      }
    }
  })

  return packages
}

async function lastFetch(pkg: string): Promise<string> {
  const command = new GetItemCommand({
    TableName: LASTFETCH_TABLE,
    Key: {
      address_package: {S: pkg},
    },
  })

  const response = await dbclient.send(command)
  if (response.Item === undefined) return ''

  const item = unmarshall(response.Item)

  return item.endCursor
}

async function saveEvents(pkg: string, events: Record<string, any>[], new_token: string) {
  const ltimestamp = new Date().toISOString()
  console.log(`saving for ${pkg}, ts ${ltimestamp}, events: ${events.length}`)
  fs.writeFileSync(`/tmp/${pkg}`, JSON.stringify(events))

  // balance changes
  // sender = 0x0 should show up in mint only
  const balances: Record<string, number> = {}

  let items: TransactWriteItem[] = [
    // update timestamp and new_token in TABLE_LASTFETCH
    {
      Update: {
        TableName: LASTFETCH_TABLE,
        Key: {
          address_package: {S: pkg},
        },
        UpdateExpression: 'SET endCursor = :new_token, ltimestamp = :ltimestamp',
        ExpressionAttributeValues: {
          ':new_token': {S: new_token},
          ':ltimestamp': {S: ltimestamp},
        },
      },
    },
  ]

  // put events in EVENTS_TABLE
  for (const event of events) {
    const item = {
      address_package: pkg,
      timestamp: event.timestamp,
      event: event.type.repr.split(/::/).pop(),
      sender: '',
      receiver: '',
      json: event.json ?? {},
    }

    switch (item.event) {
      case 'EventMint':
        item.sender = ZERO_ADDRESS
        item.receiver = event.json.address
        balances[item.receiver] = (balances[item.receiver] ?? 0) + parseInt(event.json.amount, 10)
        break
      case 'EventBurn':
        item.sender = event.json.address
        item.receiver = ZERO_ADDRESS
        balances[item.sender] = (balances[item.sender] ?? 0) - parseInt(event.json.amount, 10)
        break
      case 'EventTransfer':
        // old style mint: EventMint
        // new style mint: EventMint + EventTransfer; skip
        if (event.json.sender == ZERO_ADDRESS) {
          continue
        }
        item.sender = event.json.sender
        item.receiver = event.json.receiver
        balances[item.sender] = (balances[item.sender] ?? 0) - parseInt(event.json.amount, 10)
        balances[item.receiver] = (balances[item.receiver] ?? 0) + parseInt(event.json.amount, 10)
        break
      case 'EventPaused':
      case 'EventUnpaused':
        item.sender = event.sender.address
        break
      case 'EventTransfersFrozen':
      case 'EventTransfersUnfrozen':
        item.sender = event.sender.address
        break
      default:
        console.log(`unknown event: ${item.event}`)
        item.sender = event.sender.address
    }

    items.push({
      Put: {
        TableName: EVENTS_TABLE,
        Item: marshall(item, {removeUndefinedValues: true}),
      },
    })
  }

  // update balances in BALANCES_TABLE
  for (const [address, balance] of Object.entries(balances)) {
    items.push({
      Update: {
        TableName: BALANCES_TABLE,
        Key: {
          ticker: {S: `$${pkg.split('::')[1].toUpperCase()}`},
          address: {S: address},
        },
        UpdateExpression: 'ADD balance :balance SET ltimestamp = :ltimestamp',
        ExpressionAttributeValues: {
          ':balance': {N: `${balance}`},
          ':ltimestamp': {S: ltimestamp},
        },
      },
    })
  }

  const txWriteCommand = new TransactWriteItemsCommand({
    TransactItems: items,
  })

  await dbclient.send(txWriteCommand)
}

async function getTokenEvents(module: string, token: string): Promise<[string, object[], boolean]> {
  console.log(`fetching ${module}`)

  let cancel = () => {}
  const result: ExecutionResult<Record<string, unknown>, unknown> = await new Promise((resolve, reject) => {
    let innerResult
    if (token === '') {
      cancel = gclient.subscribe(
        {
          query: queryFirst,
          variables: {module: module, evType: module},
        },
        {
          next: data => (innerResult = data),
          error: reject,
          complete: () => resolve(innerResult),
        },
      )
    } else {
      cancel = gclient.subscribe(
        {
          query: querySubsequent,
          variables: {module: module, evType: module, after: token},
        },
        {
          next: data => (innerResult = data),
          error: reject,
          complete: () => resolve(innerResult),
        },
      )
    }
  })

  if ('errors' in result) {
    console.log(JSON.stringify(result.errors, null, 2))
    return ['', [], true]
  }

  if ('data' in result && 'events' in result.data!) {
    const new_token = result.data.events!['pageInfo'].endCursor
    const events = result.data.events!['nodes'] ?? []
    const done = !result.data.events!['pageInfo'].hasNextPage ?? true
    return [new_token, events, done]
  } else {
    return ['', [], true]
  }
}

void (async () => {
  const packages = await getPackageModules()
  console.log(JSON.stringify(packages, null, 2))

  for (const pkg of packages) {
    let token = await lastFetch(pkg)
    let packageEvents: object[] = []
    let packageDone = false

    while (!packageDone) {
      let [new_token, events, done] = await getTokenEvents(pkg, token)
      packageEvents.push(...events)
      console.log(`fetched events for ${pkg}: ${events.length}`)
      packageDone = done
      token = new_token
      if (packageDone) {
        if (packageEvents.length > 0) {
          await saveEvents(pkg, packageEvents, new_token)
          await sleep(DB_WRITE_SLEEP)
        } else {
          await sleep(API_FETCH_SLEEP)
        }
      }
    }
  }
})()
